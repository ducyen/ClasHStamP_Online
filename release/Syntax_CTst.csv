item,name,ext1st,extnxt,begin,end
file,[cONTAINER]/[nAME]_Test.c,,,"/* File generated by Đức's ClasHStamP */
#include ""[nAME].c""

#define MAX_HSM         ( 64 )
typedef struct PatternNode {
    int eventId; // ← Track the associated event
    uint64_t statePattern[ MAX_HSM ];  // UINT64_MAX = ""Don't Care""
    struct PatternNode* next;
} PatternNode;

static PatternNode* handledPatterns = NULL;
static int g_eventId;
static void* g_pParams;

static bool isRedundantPattern( HsmStates** hsmStates ) {
    for( PatternNode* node = handledPatterns; node; node = node->next ) {
        bool match = true;
        for( int i = 0; hsmStates[ i ]; i++ ) {
            if( node->statePattern[ i ] != STATE_UNDEF &&  // STATE_UNDEF = ""Don't care""
                node->statePattern[ i ] != hsmStates[ i ]->currentState ) {
                match = false;
                break;
            }
        }
        if( match ) return true;
    }
    return false;
}

static void freeHandledPatterns( void ) {
    PatternNode* current = handledPatterns;
    while( current != NULL ) {
        PatternNode* next = current->next;
        free( current );                // free the node itself
        current = next;
    }
    handledPatterns = NULL;
}

static void addPattern( HsmStates** hsmStates ) {
    PatternNode* node = malloc( sizeof( PatternNode ) );
    if( node ){
        for( int i = 0; hsmStates[ i ]; i++ ) {
            node->statePattern[ i ] = ( hsmStates[ i ]->wasQueried || hsmStates[ i ]->pHsm->wasHandled ) ? hsmStates[ i ]->currentState : STATE_UNDEF;
        }
        node->next = handledPatterns;
        handledPatterns = node;
    }
}
",
class,,,,,
b_enum,,,,,
c_enum,,,,,
i_enum,,,,,
b_struct,,,,,
c_struct,,,,,
i_struct,,,,,
constructor,,,,,
attr_group,,,,,
ctor_call,,,,,
__s_attr,,,,,
__o_attr,,,,,
__r_attr,,,,,
_ms_attr,,,,,
_mo_attr,,,,,
_mr_attr,,,,,
c_s_attr,,,,,
c_o_attr,,,,,
c_r_attr,,,,,
cms_attr,,,,,
cmo_attr,,,,,
cmr_attr,,,,,
s_s_attr,,,,,
s_o_attr,,,,,
s_r_attr,,,,,
sms_attr,,,,,
smo_attr,,,,,
smr_attr,,,,,
p_s_attr,,,,,
p_o_attr,,,,,
p_r_attr,,,,,
pms_attr,,,,,
pmo_attr,,,,,
pmr_attr,,,,,
vptr_impl,,,,,
__c_oper,,,,,
__b_oper,,,,,
vptr_decl,,,,,
_ac_oper,,,,,
_ab_oper,,,,,
l_i_oper,,,,,
l_c_oper,,,,,
l_b_oper,,,,,
lai_oper,,,,,
vptr_call,,,,,
s_i_oper,,,,,
s_c_oper,,,,,
s_b_oper,,,,,
sai_oper,,,,,
sab_oper,,,,,
event_decl,,,,,"static void [cONTAINER]_printTestCases( [tYPE]* pContext, [cONTAINER]* pUsm, int eventId, void* pParams );
void [tYPE]_printTestCases( [tYPE]* p[tYPE], int eventId, void* pParams ){
    [cONTAINER]_printTestCases( p[tYPE], &p[tYPE]->mainStm, eventId, pParams );
}
"
state_decl,"[sCOPE]_[nAME], ",,,"static uint64_t [cONTAINER]_States[] = { [vALUE]STATE_UNDEF };
",
state_entry,,,,,
state_exit,,,,,
state_impl,,,,,
transition,,,,,
trans_top,,,,,
branch,,,,,
comment,,,,,
action,,,,,
param_dir,,,,,
inheritance,,,,,
template,,,,,
statemachine,,,,"static void [sCOPE]_forEachHsmStateCombination( [tYPE]* pContext, [sCOPE]* pUsm, HsmStates** hsmStates, int depth, void (*callback)([tYPE]*, [sCOPE]*, HsmStates**) ) {
    if (hsmStates[depth] == NULL) {
        callback(pContext, pUsm, hsmStates);
        return;
    }
    HsmStates* entry = hsmStates[depth];
    for (int i = 0; entry->arrStates[i] != STATE_UNDEF; i++) {
        entry->currentState = entry->arrStates[i];
        [sCOPE]_forEachHsmStateCombination(pContext, pUsm, hsmStates, depth + 1, callback);
    }
}
[vALUE]
",
default_trans,,,,,
substm,,,,,
region,,,,,
state_action,,,,,
trans_action,,,,,
history,,,,,
deep_hist,,,,,
stm_api,"static void [sCOPE]_printCombination( [tYPE]* pContext, [sCOPE]* pUsm, HsmStates** hsmStates ) {
    if( isRedundantPattern( hsmStates ) ){
        return;
    }
    int i = 0;
    while( hsmStates[ i ] != NULL ) {
        HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
        pHsm->nCurrentState = hsmStates[ i ]->currentState;
        pHsm->nPseudostate = hsmStates[ i ]->currentState;
        char* stateName = MainTop_State_toString( pUsm, pHsm, hsmStates[ i ]->currentState );
        if( strstr( stateName, ""Init"" ) != NULL ){      // skip if state is initial pseudostate
            return;
        }
        hsmStates[ i ]->wasQueried = false;
        i++;
    }
    extern HsmStates** g_activeHsmStates;
    g_activeHsmStates = hsmStates;
    i = 0;
    while( hsmStates[ i ] != NULL ) {
        char _logBuf[ 255 ];
        HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
        i++;
    }
    clear_pre_condition();
    clear_input_event();
    clear_expected_behavior();
    clear_post_condition();
    clear_comment();
    if( [tYPE]_EventProc( pContext, g_eventId, g_pParams ) ){
        addPattern( hsmStates );
        add_line_input_event(CarBodyEvent_toString(g_eventId));
        i = 0;
        while( hsmStates[ i ] != NULL ) {
            HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
            add_line_pre_condition( MainTop_State_toString( pUsm, pHsm, hsmStates[ i ]->currentState ) );
            add_line_post_condition( MainTop_State_toString( pUsm, pHsm, pHsm->nCurrentState ) );
            if( hsmStates[ i ]->wasQueried && pHsm->wasHandled ){ add_line_comment( ""was queried and handled"" ); }
            else if( hsmStates[ i ]->wasQueried ){                add_line_comment( ""was queried"" );             }
            else if( pHsm->wasHandled ){                          add_line_comment( ""was handled"" );             }
            else{                                                 add_line_comment( ""unchanged or don't care"" ); }
            i++;
        }
        csv_write_row();
    }
    g_activeHsmStates = NULL; // cleanup
}
static void [sCOPE]_printTestCases( [tYPE]* pContext, [sCOPE]* pUsm, int eventId, void* pParams ) {
    HsmStates* hsmStates[] = {                                  // NULL-terminated list of HSMs
[mODIFIER]        NULL
    };
    g_eventId = eventId;
    g_pParams = pParams;
    [sCOPE]_forEachHsmStateCombination( pContext, pUsm, hsmStates, 0, [sCOPE]_printCombination );
    freeHandledPatterns();
}
",,,"        &( HsmStates ){ .pEventProc = [cONTAINER]_EventProc, .pHsm = &pUsm->[cONTAINER], .arrStates = [cONTAINER]_States }, [mODIFIER]
","/* [cONTAINER]_StateDefaultTrans( p[tYPE], &pUsm->[mODIFIER] ) */"
api_call,,,,,
friend,,,,,
visibility,,,,,
object,,,,,
