/* File generated by Đức's ClasHStamP */
#include "CarBody.c"

#define MAX_HSM         ( 64 )
typedef struct PatternNode {
    int eventId; // ← Track the associated event
    uint64_t statePattern[ MAX_HSM ];  // UINT64_MAX = "Don't Care"
    struct PatternNode* next;
} PatternNode;

static PatternNode* handledPatterns = NULL;
static int g_eventId;
static void* g_pParams;

static bool isRedundantPattern( HsmStates** hsmStates ) {
    for( PatternNode* node = handledPatterns; node; node = node->next ) {
        bool match = true;
        for( int i = 0; hsmStates[ i ]; i++ ) {
            if( node->statePattern[ i ] != STATE_UNDEF &&  // STATE_UNDEF = "Don't care"
                node->statePattern[ i ] != hsmStates[ i ]->currentState ) {
                match = false;
                break;
            }
        }
        if( match ) return true;
    }
    return false;
}

static void freeHandledPatterns( void ) {
    PatternNode* current = handledPatterns;
    while( current != NULL ) {
        PatternNode* next = current->next;
        free( current );                // free the node itself
        current = next;
    }
    handledPatterns = NULL;
}

static void addPattern( HsmStates** hsmStates ) {
    PatternNode* node = malloc( sizeof( PatternNode ) );
    if( node ){
        for( int i = 0; hsmStates[ i ]; i++ ) {
            node->statePattern[ i ] = ( hsmStates[ i ]->wasQueried || hsmStates[ i ]->pHsm->wasHandled ) ? hsmStates[ i ]->currentState : STATE_UNDEF;
        }
        node->next = handledPatterns;
        handledPatterns = node;
    }
}
static void MainTop_printTestCases( CarBody* pContext, MainTop* pUsm, int eventId, void* pParams );
void CarBody_printTestCases( CarBody* pCarBody, int eventId, void* pParams ){
    MainTop_printTestCases( pCarBody, &pCarBody->mainStm, eventId, pParams );
}
static void MainTop_forEachHsmStateCombination( CarBody* pContext, MainTop* pUsm, HsmStates** hsmStates, int depth, void (*callback)(CarBody*, MainTop*, HsmStates**) ) {
    if (hsmStates[depth] == NULL) {
        callback(pContext, pUsm, hsmStates);
        return;
    }
    HsmStates* entry = hsmStates[depth];
    for (int i = 0; entry->arrStates[i] != STATE_UNDEF; i++) {
        entry->currentState = entry->arrStates[i];
        MainTop_forEachHsmStateCombination(pContext, pUsm, hsmStates, depth + 1, callback);
    }
}
static uint64_t CarOnRgn1Hsm_States[] = { MainTop_Reversed, MainTop_Drive, MainTop_GearInit, MainTop_Neutral, MainTop_Parked, STATE_UNDEF };
static uint64_t CarOnRgn2Hsm_States[] = { MainTop_InfotainmentInit, MainTop_BackCamera, MainTop_DisplayAvail, STATE_UNDEF };
static uint64_t MainStmHsm_States[] = { MainTop_CarOnRgn1Init, MainTop_EngineIdle, MainTop_EngineAccel, MainTop_EngineDeccel, MainTop_EngineMgmtInit, MainTop_CarOff, MainTop_MainInit, STATE_UNDEF };

static void MainTop_printCombination( CarBody* pContext, MainTop* pUsm, HsmStates** hsmStates ) {
    if( isRedundantPattern( hsmStates ) ){
        return;
    }
    int i = 0;
    while( hsmStates[ i ] != NULL ) {
        HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
        pHsm->nCurrentState = hsmStates[ i ]->currentState;
        pHsm->nPseudostate = hsmStates[ i ]->currentState;
        char* stateName = MainTop_State_toString( pUsm, pHsm, hsmStates[ i ]->currentState );
        if( strstr( stateName, "Init" ) != NULL ){      // skip if state is initial pseudostate
            return;
        }
        hsmStates[ i ]->wasQueried = false;
        i++;
    }
    extern HsmStates** g_activeHsmStates;
    g_activeHsmStates = hsmStates;
    i = 0;
    while( hsmStates[ i ] != NULL ) {
        char _logBuf[ 255 ];
        HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
        i++;
    }
    clear_pre_condition();
    clear_input_event();
    clear_expected_behavior();
    clear_post_condition();
    clear_comment();
    if( CarBody_EventProc( pContext, g_eventId, g_pParams ) ){
        addPattern( hsmStates );
        add_line_input_event(CarBodyEvent_toString(g_eventId));
        i = 0;
        while( hsmStates[ i ] != NULL ) {
            HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
            add_line_pre_condition( MainTop_State_toString( pUsm, pHsm, hsmStates[ i ]->currentState ) );
            add_line_post_condition( MainTop_State_toString( pUsm, pHsm, pHsm->nCurrentState ) );
            if( hsmStates[ i ]->wasQueried && pHsm->wasHandled ){ add_line_comment( "was queried and handled" ); }
            else if( hsmStates[ i ]->wasQueried ){                add_line_comment( "was queried" );             }
            else if( pHsm->wasHandled ){                          add_line_comment( "was handled" );             }
            else{                                                 add_line_comment( "unchanged or don't care" ); }
            i++;
        }
        csv_write_row();
    }
    g_activeHsmStates = NULL; // cleanup
}
static void MainTop_printTestCases( CarBody* pContext, MainTop* pUsm, int eventId, void* pParams ) {
    HsmStates* hsmStates[] = {                                  // NULL-terminated list of HSMs
        &( HsmStates ){ .pEventProc = CarOnRgn1Hsm_EventProc, .pHsm = &pUsm->CarOnRgn1Hsm, .arrStates = CarOnRgn1Hsm_States }, 
        &( HsmStates ){ .pEventProc = CarOnRgn2Hsm_EventProc, .pHsm = &pUsm->CarOnRgn2Hsm, .arrStates = CarOnRgn2Hsm_States }, 
        &( HsmStates ){ .pEventProc = MainStmHsm_EventProc, .pHsm = &pUsm->MainStmHsm, .arrStates = MainStmHsm_States }, 
        NULL
    };
    g_eventId = eventId;
    g_pParams = pParams;
    MainTop_forEachHsmStateCombination( pContext, pUsm, hsmStates, 0, MainTop_printCombination );
    freeHandledPatterns();
}
