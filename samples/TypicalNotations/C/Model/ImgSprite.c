/* File generated by Đức's ClasHStamP */
#define __ImgSprite_INTERNAL__
#include "CommonInclude.h"
#include "ImgSprite.h"
/** @public @memberof ImgSprite */
void ImgSprite_setOffset(
    ImgSprite* pImgSprite,
    int x,
    int y
){
    pImgSprite->m_offset.x = x;
    pImgSprite->m_offset.y = y;
    pImgSprite->m_center.x = pImgSprite->m_rect.x + pImgSprite->m_rect.w / 2 + pImgSprite->m_offset.x;
    pImgSprite->m_center.y = pImgSprite->m_rect.y + pImgSprite->m_rect.h / 2 + pImgSprite->m_offset.y;
    pImgSprite->m_updated = true;
} /* ImgSprite_setOffset */

/** @public @memberof ImgSprite */
const SDL_Point* ImgSprite_getOffset(
    ImgSprite* pImgSprite
){
    return &pImgSprite->m_offset;
} /* ImgSprite_getOffset */

/** @public @memberof ImgSprite */
const SDL_Rect* ImgSprite_getBoundary(
    ImgSprite* pImgSprite
){
    return &pImgSprite->m_rect;
} /* ImgSprite_getBoundary */

/** @public @memberof ImgSprite */
static const SDL_Point* ImgSprite_getCenter(
    Sprite* pSprite
){
    ImgSprite* pImgSprite = ( ImgSprite* )pSprite;
    return &pImgSprite->m_center;
} /* ImgSprite_getCenter */

/** @public @memberof ImgSprite */
void ImgSprite_setRotation(
    ImgSprite* pImgSprite,
    double value
){
    pImgSprite->m_angle = value;
    pImgSprite->m_updated = true;
} /* ImgSprite_setRotation */

/** @public @memberof ImgSprite */
double ImgSprite_getRotation(
    ImgSprite* pImgSprite
){
    return pImgSprite->m_angle;
} /* ImgSprite_getRotation */

/** @public @memberof ImgSprite */
void ImgSprite_setSpriteCoords(
    ImgSprite* pImgSprite,
    int x,
    int y
){
    pImgSprite->m_spriteCoords.x = x;
    pImgSprite->m_spriteCoords.y = y;
} /* ImgSprite_setSpriteCoords */

/** @public @memberof ImgSprite */
void ImgSprite_setBrightness(
    ImgSprite* pImgSprite,
    double value
){
    pImgSprite->m_brightness = value;
} /* ImgSprite_setBrightness */

/** @public @memberof ImgSprite */
static void ImgSprite_draw0(
    Sprite* pSprite,
    SDL_Renderer* renderer
){
    ImgSprite* pImgSprite = ( ImgSprite* )pSprite;
    ImgSprite* sprite = pImgSprite;
    EventListener* pCurListener = sprite->m_onDrawListeners;
    while( pCurListener != null ){
        if( EventListener_getType( pCurListener ) == 0 ){
            EventListener_actionPerformed( pCurListener, sprite, null );
        }
        pCurListener = EventListener_getNext( pCurListener );
    }
} /* ImgSprite_draw0 */

/** @public @memberof ImgSprite */
static void ImgSprite_update(
    Sprite* pSprite
){
    ImgSprite* pImgSprite = ( ImgSprite* )pSprite;
    if( !Sprite_isUpdated( pImgSprite ) ){
        return;
    }
    Constraint* pCurConstraint = pImgSprite->m_constraints;
    while( pCurConstraint != null ){
        Constraint_apply( pCurConstraint, pImgSprite );
        pCurConstraint = Constraint_getNext( pCurConstraint );
    }
    pImgSprite->m_updated = false;
} /* ImgSprite_update */

/** @public @memberof ImgSprite */
static void ImgSprite_updateMouseState(
    Sprite* pSprite,
    int x,
    int y,
    int mouseEvent
){
    ImgSprite* pImgSprite = ( ImgSprite* )pSprite;
    ImgSprite* sprite = pImgSprite;
    int mouseX = x;
    int mouseY = y;
    SDL_Rect rect = sprite->m_rect;
    rect.x += sprite->m_offset.x;
    rect.y += sprite->m_offset.y;

    if (mouseX >= rect.x && mouseX < rect.x + rect.w &&
        mouseY >= rect.y && mouseY < rect.y + rect.h
    ) {
        EventListener* pCurListener = pImgSprite->m_mouseListeners;
        while( pCurListener != null ){
            if( EventListener_getType( pCurListener ) == mouseEvent ){
                EventListener_actionPerformed( pCurListener, pImgSprite, null );
            }
            pCurListener = EventListener_getNext( pCurListener );
        }
    }
} /* ImgSprite_updateMouseState */

/** @public @memberof ImgSprite */
static void ImgSprite_draw1(
    Sprite* pSprite,
    SDL_Renderer* renderer
){
    ImgSprite* pImgSprite = (ImgSprite*)pSprite;
    int width, height;

    // Set texture color modulation (brightness)
    if ( pImgSprite->m_image ) {
        SDL_SetTextureColorMod(
            pImgSprite->m_image,
            pImgSprite->m_brightness * 255,
            pImgSprite->m_brightness * 255,
            pImgSprite->m_brightness * 255
        );
    }

    // Execute transformation
    SDL_Rect dstRect = pImgSprite->m_rect;
    dstRect.x += pImgSprite->m_offset.x;
    dstRect.y += pImgSprite->m_offset.y;

    // Compute source rectangle if sprite sheet coordinates are specified
    SDL_Rect* pSrcRect = NULL;
    SDL_Rect srcRect;

    if ( pImgSprite->m_spriteCoords.w > 0 && pImgSprite->m_spriteCoords.h > 0 ) {
        // Get full texture size
        SDL_QueryTexture(pImgSprite->m_image, NULL, NULL, &width, &height);

        int spriteWidth = width / pImgSprite->m_spriteCoords.w;
        int spriteHeight = height / pImgSprite->m_spriteCoords.h;

        srcRect.x = spriteWidth * pImgSprite->m_spriteCoords.x;
        srcRect.y = spriteHeight * pImgSprite->m_spriteCoords.y;
        srcRect.w = spriteWidth;
        srcRect.h = spriteHeight;

        pSrcRect = &srcRect;
    }

    // Render the texture (with or without srcRect)
    if ( pImgSprite->m_image ) {
        SDL_RenderCopyEx(renderer, pImgSprite->m_image, pSrcRect, &dstRect, pImgSprite->m_angle, NULL, SDL_FLIP_NONE);
    }

    // Reset transformation
    pImgSprite->m_angle = 0;
    pImgSprite->m_offset.x = 0;
    pImgSprite->m_offset.y = 0;

    // Event dispatch
    ImgSprite* sprite = pImgSprite;
    EventListener* pCurListener = sprite->m_onDrawListeners;
    while ( pCurListener != null ) {
        if ( EventListener_getType(pCurListener) == 1 ) {
            EventListener_actionPerformed(pCurListener, sprite, null);
        }
        pCurListener = EventListener_getNext(pCurListener);
    }
} /* ImgSprite_draw1 */

/** @public @memberof ImgSprite */
static bool ImgSprite_load(
    Sprite* pSprite,
    SDL_Renderer* renderer
){
    ImgSprite* pImgSprite = ( ImgSprite* )pSprite;
    char sRelPath[ 256 ];
    sprintf( sRelPath, "%s/../%s", getInputDir(), pImgSprite->m_imgPath );
    pImgSprite->m_image = IMG_LoadTexture(renderer, sRelPath);
    if (!pImgSprite->m_image) {
        printf("Failed to load image: %s\n", IMG_GetError());
    }else{

        // Query the original texture to get its width, height, and format
        Uint32 format;
        int width, height;
        SDL_QueryTexture(pImgSprite->m_image, &format, NULL, &width, &height);

        // Create a new texture with the same format and dimensions
        pImgSprite->m_buffer = SDL_CreateTexture(renderer, format, SDL_TEXTUREACCESS_TARGET, width, height);
        if (!pImgSprite->m_buffer) {
            printf("Failed to create new texture: %s\n", SDL_GetError());
            return false;
        }

        // Set the blend mode for the new texture to enable alpha blending
        SDL_SetTextureBlendMode(pImgSprite->m_buffer, SDL_BLENDMODE_BLEND);
    }

    int width, height;
    // Get the size of the renderer
    if (SDL_GetRendererOutputSize(renderer, &width, &height) != 0) {
        printf("Error getting renderer size: %s\n", SDL_GetError());
    }
    
    pImgSprite->m_rect = (SDL_Rect){
        pImgSprite->m_iniRect.x * width, 
        pImgSprite->m_iniRect.y * height, 
        pImgSprite->m_iniRect.w * width, 
        pImgSprite->m_iniRect.h * height
    };

    ImgSprite_setOffset( pImgSprite, 0, 0 );

    return true;
} /* ImgSprite_load */

/** @public @memberof ImgSprite */
static void ImgSprite_free(
    Sprite* pSprite
){
    ImgSprite* pImgSprite = ( ImgSprite* )pSprite;
    if (pImgSprite->m_image) {
        SDL_DestroyTexture(pImgSprite->m_image);
    }
    if (pImgSprite->m_buffer) {
        SDL_DestroyTexture(pImgSprite->m_buffer);
    }
} /* ImgSprite_free */

Sprite* ImgSprite_Copy( ImgSprite* pImgSprite, const ImgSprite* pSource ){
    Sprite_Copy( ( Sprite* )pImgSprite, ( Sprite* )pSource );
    pImgSprite->m_buffer = pSource->m_buffer;
    pImgSprite->m_center = pSource->m_center;
    pImgSprite->m_angle = pSource->m_angle;
    pImgSprite->m_spriteCoords = pSource->m_spriteCoords;
    pImgSprite->m_constraints = pSource->m_constraints;
    pImgSprite->m_mouseListeners = pSource->m_mouseListeners;
    pImgSprite->m_onDrawListeners = pSource->m_onDrawListeners;
    return ( Sprite* )pImgSprite;
}
const SpriteVtbl gImgSpriteVtbl = {
    .pgetCenter                  = ImgSprite_getCenter,
    .pdraw0                      = ImgSprite_draw0,
    .pupdate                     = ImgSprite_update,
    .pupdateMouseState           = ImgSprite_updateMouseState,
    .pdraw1                      = ImgSprite_draw1,
    .pload                       = ImgSprite_load,
    .pfree                       = ImgSprite_free,
};
