extern "C" {
/* File generated by Đức's ClasHStamP */
#include "TrackToConstraint.c"

#define MAX_HSM         ( 64 )
typedef struct PatternNode {
    int eventId; // ← Track the associated event
    uint64_t statePattern[ MAX_HSM ];  // UINT64_MAX = "Don't Care"
    struct PatternNode* next;
} PatternNode;

static PatternNode* handledPatterns = NULL;
static int g_eventId;
static void* g_pParams;

static bool isRedundantPattern( HsmStates** hsmStates ) {
    for( PatternNode* node = handledPatterns; node; node = node->next ) {
        bool match = true;
        for( int i = 0; hsmStates[ i ]; i++ ) {
            if( node->statePattern[ i ] != STATE_UNDEF &&  // STATE_UNDEF = "Don't care"
                node->statePattern[ i ] != hsmStates[ i ]->currentState ) {
                match = false;
                break;
            }
        }
        if( match ) return true;
    }
    return false;
}

static void freeHandledPatterns( void ) {
    PatternNode* current = handledPatterns;
    while( current != NULL ) {
        PatternNode* next = current->next;
        free( current );                // free the node itself
        current = next;
    }
    handledPatterns = NULL;
}

static void addPattern( HsmStates** hsmStates ) {
    PatternNode* node = malloc( sizeof( PatternNode ) );
    if( node ){
        for( int i = 0; hsmStates[ i ]; i++ ) {
            node->statePattern[ i ] = ( hsmStates[ i ]->wasQueried || hsmStates[ i ]->pHsm->bHandled ) ? hsmStates[ i ]->currentState : STATE_UNDEF;
        }
        node->next = handledPatterns;
        handledPatterns = node;
    }
}
}