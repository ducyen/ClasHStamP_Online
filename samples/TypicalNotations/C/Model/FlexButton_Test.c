/* File generated by Đức's ClasHStamP */
#include "FlexButton.c"

#define MAX_HSM         ( 64 )
typedef struct PatternNode {
    int eventId; // ← Track the associated event
    uint64_t statePattern[ MAX_HSM ];  // UINT64_MAX = "Don't Care"
    struct PatternNode* next;
} PatternNode;

static PatternNode* handledPatterns = NULL;
static int g_eventId;
static void* g_pParams;

static bool isRedundantPattern( HsmStates** hsmStates ) {
    for( PatternNode* node = handledPatterns; node; node = node->next ) {
        bool match = true;
        for( int i = 0; hsmStates[ i ]; i++ ) {
            if( node->statePattern[ i ] != STATE_UNDEF &&  // STATE_UNDEF = "Don't care"
                node->statePattern[ i ] != hsmStates[ i ]->currentState ) {
                match = false;
                break;
            }
        }
        if( match ) return true;
    }
    return false;
}

static void freeHandledPatterns( void ) {
    PatternNode* current = handledPatterns;
    while( current != NULL ) {
        PatternNode* next = current->next;
        free( current );                // free the node itself
        current = next;
    }
    handledPatterns = NULL;
}

static void addPattern( HsmStates** hsmStates ) {
    PatternNode* node = malloc( sizeof( PatternNode ) );
    if( node ){
        for( int i = 0; hsmStates[ i ]; i++ ) {
            node->statePattern[ i ] = ( hsmStates[ i ]->wasQueried || hsmStates[ i ]->pHsm->wasHandled ) ? hsmStates[ i ]->currentState : STATE_UNDEF;
        }
        node->next = handledPatterns;
        handledPatterns = node;
    }
}
static void FlexBtnTop_printTestCases( FlexButton* pContext, FlexBtnTop* pUsm, int eventId, void* pParams );
void FlexButton_printTestCases( FlexButton* pFlexButton, int eventId, void* pParams ){
    FlexBtnTop_printTestCases( pFlexButton, &pFlexButton->mainStm, eventId, pParams );
}
static void FlexBtnTop_forEachHsmStateCombination( FlexButton* pContext, FlexBtnTop* pUsm, HsmStates** hsmStates, int depth, void (*callback)(FlexButton*, FlexBtnTop*, HsmStates**) ) {
    if (hsmStates[depth] == NULL) {
        callback(pContext, pUsm, hsmStates);
        return;
    }
    HsmStates* entry = hsmStates[depth];
    for (int i = 0; entry->arrStates[i] != STATE_UNDEF; i++) {
        entry->currentState = entry->arrStates[i];
        FlexBtnTop_forEachHsmStateCombination(pContext, pUsm, hsmStates, depth + 1, callback);
    }
}
static uint64_t ReadyRgn1Hsm_States[] = { FlexBtnTop_InitialReadyRegion1, FlexBtnTop_Missed, FlexBtnTop_Idle, FlexBtnTop_UnPressed, FlexBtnTop_Pressed, STATE_UNDEF };
static uint64_t FlexBtnStmHsm_States[] = { FlexBtnTop_ToggleStyle, FlexBtnTop_SelectStyle, FlexBtnTop_SlideStyle, FlexBtnTop_InitialReady, FlexBtnTop_PushStyle, FlexBtnTop_InitialMain, STATE_UNDEF };

static void FlexBtnTop_printCombination( FlexButton* pContext, FlexBtnTop* pUsm, HsmStates** hsmStates ) {
    if( isRedundantPattern( hsmStates ) ){
        return;
    }
    int i = 0;
    while( hsmStates[ i ] != NULL ) {
        HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
        pHsm->nCurrentState = hsmStates[ i ]->currentState;
        pHsm->nPseudostate = hsmStates[ i ]->currentState;
        char* stateName = MainTop_State_toString( pUsm, pHsm, hsmStates[ i ]->currentState );
        if( strstr( stateName, "Init" ) != NULL ){      // skip if state is initial pseudostate
            return;
        }
        hsmStates[ i ]->wasQueried = false;
        i++;
    }
    extern HsmStates** g_activeHsmStates;
    g_activeHsmStates = hsmStates;
    i = 0;
    while( hsmStates[ i ] != NULL ) {
        char _logBuf[ 255 ];
        HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
        i++;
    }
    clear_pre_condition();
    clear_input_event();
    clear_expected_behavior();
    clear_post_condition();
    clear_comment();
    if( FlexButton_EventProc( pContext, g_eventId, g_pParams ) ){
        addPattern( hsmStates );
        add_line_input_event(CarBodyEvent_toString(g_eventId));
        i = 0;
        while( hsmStates[ i ] != NULL ) {
            HdStateMachine* pHsm = hsmStates[ i ]->pHsm;
            add_line_pre_condition( MainTop_State_toString( pUsm, pHsm, hsmStates[ i ]->currentState ) );
            add_line_post_condition( MainTop_State_toString( pUsm, pHsm, pHsm->nCurrentState ) );
            if( hsmStates[ i ]->wasQueried && pHsm->wasHandled ){ add_line_comment( "was queried and handled" ); }
            else if( hsmStates[ i ]->wasQueried ){                add_line_comment( "was queried" );             }
            else if( pHsm->wasHandled ){                          add_line_comment( "was handled" );             }
            else{                                                 add_line_comment( "unchanged or don't care" ); }
            i++;
        }
        csv_write_row();
    }
    g_activeHsmStates = NULL; // cleanup
}
static void FlexBtnTop_printTestCases( FlexButton* pContext, FlexBtnTop* pUsm, int eventId, void* pParams ) {
    HsmStates* hsmStates[] = {                                  // NULL-terminated list of HSMs
        &( HsmStates ){ .pEventProc = ReadyRgn1Hsm_EventProc, .pHsm = &pUsm->ReadyRgn1Hsm, .arrStates = ReadyRgn1Hsm_States }, 
        &( HsmStates ){ .pEventProc = FlexBtnStmHsm_EventProc, .pHsm = &pUsm->FlexBtnStmHsm, .arrStates = FlexBtnStmHsm_States }, 
        NULL
    };
    g_eventId = eventId;
    g_pParams = pParams;
    FlexBtnTop_forEachHsmStateCombination( pContext, pUsm, hsmStates, 0, FlexBtnTop_printCombination );
    freeHandledPatterns();
}
