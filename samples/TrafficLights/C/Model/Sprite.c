/* File generated by Đức's ClasHStamP */
#define __Sprite_INTERNAL__
#include "CommonInclude.h"
#include "Sprite.h"
/** @public @memberof Sprite */
void Sprite_addConstraint(
    Sprite* pSprite,
    Constraint* constraint
){
    if( pSprite->m_constraintCount < sizeof( pSprite->m_constraints ) / sizeof( pSprite->m_constraints[ 0 ] ) ){
        pSprite->m_constraints[ pSprite->m_constraintCount ] = constraint;
        pSprite->m_constraintCount++;
    }else{
        assert( 0 );
    }
} /* Sprite_addConstraint */

/** @public @memberof Sprite */
void Sprite_setLocation(
    Sprite* pSprite,
    int x,
    int y
){
    pSprite->m_rect.x = x;
    pSprite->m_rect.y = y;
} /* Sprite_setLocation */

/** @public @memberof Sprite */
void Sprite_setAngle(
    Sprite* pSprite,
    double value
){
    pSprite->m_angle = value;
} /* Sprite_setAngle */

/** @public @memberof Sprite */
void Sprite_setBrightness(
    Sprite* pSprite,
    double value
){
    pSprite->m_brightness = value;
} /* Sprite_setBrightness */

/** @public @memberof Sprite */
void Sprite_draw(
    Sprite* pSprite,
    SDL_Surface* screenSurface
){
    SDL_Rect rect = ( SDL_Rect ){ 
        pSprite->m_iniRect.x * screenSurface->w, 
        pSprite->m_iniRect.y * ( screenSurface->h ), 
        pSprite->m_iniRect.w  * screenSurface->w, 
        pSprite->m_iniRect.h  * ( screenSurface->h ) - 22
    };

    // Rotate and scale the image
    SDL_Surface* transformedSurface = rotozoomSurface(
        pSprite->m_image, 
        pSprite->m_angle, 
        1.0,
        0
    );

    // Change brightness
    SDL_SetSurfaceColorMod( 
        transformedSurface, 
        pSprite->m_brightness * 255, 
        pSprite->m_brightness * 255, 
        pSprite->m_brightness * 255
    );

    // Calculate the size of the surface after rotation and zoom
    int dstwidth, dstheight;
    rotozoomSurfaceSize(pSprite->m_image->w, pSprite->m_image->h, pSprite->m_angle, 1.0, &dstwidth, &dstheight);
    double zoom = ( double )dstwidth / pSprite->m_image->w;

    // Adjust the destination rectangle
    rect = ( SDL_Rect ){
        rect.x + rect.w / 2 - rect.w * zoom / 2,
        rect.y + rect.h / 2 - rect.h * zoom / 2,
        rect.w * zoom,
        rect.h * zoom
    };

    // Blit the surface on to screen
    SDL_BlitScaled(transformedSurface, NULL, screenSurface, &rect);

    // Free memory
    SDL_FreeSurface(transformedSurface);
} /* Sprite_draw */

/** @public @memberof Sprite */
bool Sprite_load(
    Sprite* pSprite
){
    char sRelPath[ 256 ];
    sprintf( sRelPath, "%s/../%s", getInputDir(), pSprite->m_imgPath );
    pSprite->m_image = IMG_Load(sRelPath);
    if (!pSprite->m_image) {
        printf("Failed to load image: %s\n", IMG_GetError());
        return false;
    }
    return true;
} /* Sprite_load */

/** @public @memberof Sprite */
void Sprite_free(
    Sprite* pSprite
){
    if (pSprite->m_image) {
        SDL_FreeSurface(pSprite->m_image);
    }
} /* Sprite_free */

Sprite* Sprite_Copy( Sprite* pSprite, const Sprite* pSource ){
    pSprite->m_iniRect = pSource->m_iniRect;
    pSprite->m_imgPath = pSource->m_imgPath;
    pSprite->m_image = pSource->m_image;
    pSprite->m_rect = pSource->m_rect;
    pSprite->m_angle = pSource->m_angle;
    pSprite->m_brightness = pSource->m_brightness;
    memcpy( pSprite->m_constraints, pSource->m_constraints, sizeof( pSprite->m_constraints ) );
    pSprite->m_constraintCount = pSource->m_constraintCount;
    return ( Sprite* )pSprite;
}
