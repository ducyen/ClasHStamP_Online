/* File generated by Đức's ClasHStamP */
#define __AttachConstraint_INTERNAL__
#include "CommonInclude.h"
#include "AttachConstraint.h"
/** @public @memberof AttachConstraint */
static void AttachConstraint_apply(
    AttachConstraint* pAttachConstraint,
    Sprite* target
){
    if( pAttachConstraint->m_influence == 0 ){
        return;
    }

    ImgSprite* child  = ( ImgSprite* )*pAttachConstraint->m_source;
    ImgSprite* parent = ( ImgSprite* )target;
    SDL_Point* childOfs  = ImgSprite_getOffset( child  );
    //SDL_Point* parentOfs = ImgSprite_getOffset( parent );

    // Calculate the new position of the child based on the parent's transformation
    double angleRad = ImgSprite_getRotation( parent ) * M_PI / 180.0f;
    double cosAngle = cos(angleRad);
    double sinAngle = sin(angleRad);

    // Calculate the initial offset between child and parent
    const SDL_Rect* childRect  = ImgSprite_getBoundary( child  );
    const SDL_Rect* parentRect = ImgSprite_getBoundary( parent );
    double offsetX = childRect->x - parentRect->x;
    double offsetY = childRect->y - parentRect->y;

    int deltaX = parentRect->x + offsetX * cosAngle - offsetY * sinAngle - childRect->x;
    int deltaY = parentRect->y + offsetX * sinAngle + offsetY * cosAngle - childRect->y;
    //child->rotation = parent->rotation;

    ImgSprite_setOffset( child, childOfs->x + deltaX, childOfs->y + deltaY );
} /* AttachConstraint_apply */

TransformConstraint* AttachConstraint_Copy( AttachConstraint* pAttachConstraint, const AttachConstraint* pSource ){
    TransformConstraint_Copy( ( TransformConstraint* )pAttachConstraint, ( TransformConstraint* )pSource );
    return ( Constraint* )pAttachConstraint;
}
const ConstraintVtbl gAttachConstraintVtbl = {
    .papply                      = AttachConstraint_apply,
};
