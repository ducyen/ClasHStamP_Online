/* File generated by Đức's ClasHStamP */
#define __PhxSprite_INTERNAL__
#include "CommonInclude.h"
#include "PhxSprite.h"
#include "ObjsBuilder.h"                                        
/** @public @memberof PhxSprite */
static void PhxSprite_draw0(
    Sprite* pSprite,
    SDL_Renderer* renderer
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
    // Apply joints
    PhxJoint* pCurJoint = pPhxSprite->m_joints;
    while( pCurJoint != null ){
        PhxJoint_apply( pCurJoint, ( Sprite* )pPhxSprite );
        pCurJoint = PhxJoint_getNext( pCurJoint );
    }    
} /* PhxSprite_draw0 */

/** @public @memberof PhxSprite */
static void PhxSprite_update(
    Sprite* pSprite
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
    // Update joints
    /*
    PhxJoint* pCurJoint = pPhxSprite->m_joints;
    while( pCurJoint != null ){
        PhxJoint_apply( pCurJoint, ( Sprite* )pPhxSprite );
        pCurJoint = PhxJoint_getNext( pCurJoint );
    }
    */
} /* PhxSprite_update */

/** @public @memberof PhxSprite */
static void PhxSprite_updateMouseState(
    Sprite* pSprite,
    int x,
    int y,
    int mouseEvent
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
} /* PhxSprite_updateMouseState */

/** @public @memberof PhxSprite */
static void PhxSprite_draw1(
    Sprite* pSprite,
    SDL_Renderer* renderer
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
    // Get the size of the renderer
    int SCREEN_WIDTH, SCREEN_HEIGHT;
    if (SDL_GetRendererOutputSize(renderer, &SCREEN_WIDTH, &SCREEN_HEIGHT) != 0) {
        printf("Error getting renderer size: %s\n", SDL_GetError());
    }

    // Render the texture
    cpVect pos = cpBodyGetPosition(pPhxSprite->m_body);
    cpFloat angle = cpBodyGetAngle(pPhxSprite->m_body);
    double degrees = -angle * (180.0 / M_PI); // Convert radians to degrees
    //cpBB bb = cpShapeCacheBB( pPhxSprite->m_shape );
    //SDL_Rect rect = ( SDL_Rect ){ .x = bb.l, .y = SCREEN_HEIGHT - bb.t, .w = bb.r - bb.l, .h = bb.t - bb.b };
    SDL_Rect rect = pPhxSprite->m_rect;
    rect.x = pos.x - pPhxSprite->m_center.x;
    rect.y = SCREEN_HEIGHT - pos.y - pPhxSprite->m_center.y;

    SDL_Point center = { pPhxSprite->m_center.x, pPhxSprite->m_center.y };
    SDL_RenderCopyEx(renderer, pPhxSprite->m_image, NULL, &rect, degrees, &center, SDL_FLIP_NONE);
} /* PhxSprite_draw1 */

/** @public @memberof PhxSprite */
static bool PhxSprite_load(
    Sprite* pSprite,
    SDL_Renderer* renderer
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
    char sRelPath[ 256 ];
    sprintf( sRelPath, "%s/../%s", getInputDir(), pPhxSprite->m_imgPath );
    // Load PNG image
    SDL_Texture* pPngImg = IMG_LoadTexture(renderer, sRelPath);
    if (!pPngImg) {
        printf("Failed to load image: %s\n", IMG_GetError());
        return false;
    }

    // Get the size of the renderer
    int SCREEN_WIDTH, SCREEN_HEIGHT;
    if (SDL_GetRendererOutputSize(renderer, &SCREEN_WIDTH, &SCREEN_HEIGHT) != 0) {
        printf("Error getting renderer size: %s\n", SDL_GetError());
    }

    pPhxSprite->m_rect = (SDL_Rect){
        pPhxSprite->m_iniRect.x * SCREEN_WIDTH, 
        pPhxSprite->m_iniRect.y * SCREEN_HEIGHT, 
        pPhxSprite->m_iniRect.w * SCREEN_WIDTH, 
        pPhxSprite->m_iniRect.h * SCREEN_HEIGHT
    };

    int textureWidth = pPhxSprite->m_rect.w;
    int textureHeight = pPhxSprite->m_rect.h;

    pPhxSprite->m_image = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, textureWidth, textureHeight);

    pPhxSprite->m_center.x *= (double)textureWidth;
    pPhxSprite->m_center.y = pPhxSprite->m_center.y * (double)textureHeight;
    for (int i = 0; i < pPhxSprite->m_vertsCnt; i++) {
        pPhxSprite->m_verts[ i ].x *= (double)textureWidth;
        pPhxSprite->m_verts[ i ].y = -pPhxSprite->m_verts[ i ].y * textureHeight;
    }

    int concaveVertexCount = pPhxSprite->m_vertsCnt;
    cpVect* concaveVertices = pPhxSprite->m_verts;
    pPhxSprite->m_decomposedPolygons = decomposeConcavePolygon(concaveVertices, concaveVertexCount);
    assert(pPhxSprite->m_decomposedPolygons != NULL);

    // Set the blend mode for the new texture to enable alpha blending
    SDL_SetTextureBlendMode(pPhxSprite->m_image, SDL_BLENDMODE_BLEND);
    // Set the render target to the buffer texture
    SDL_SetRenderTarget(renderer, pPhxSprite->m_image);

    //SDL_RenderCopy( renderer, pPngImg, NULL, NULL );

    // Draw the polygon on the texture
    for (int i = 0; i < pPhxSprite->m_vertsCnt; i++) {
        cpVect v1 = pPhxSprite->m_verts[i];
        cpVect v2 = pPhxSprite->m_verts[(i + 1) % pPhxSprite->m_vertsCnt];

        // Convert polygon coordinates to texture coordinates
        int x1 = (int)(v1.x + pPhxSprite->m_center.x);
        int y1 = (int)(pPhxSprite->m_center.y - v1.y);
        int x2 = (int)(v2.x + pPhxSprite->m_center.x);
        int y2 = (int)(pPhxSprite->m_center.y - v2.y);

        lineRGBA(renderer, x1, y1, x2, y2, 0, 0, 0, 255);
    }

    // Recover render target
    SDL_SetRenderTarget(renderer, NULL);

    // Free PNG image
    SDL_DestroyTexture(pPngImg);
    
    // Set physic information
    cpFloat totalMoment = 0.0;
    cpPolygon *current = pPhxSprite->m_decomposedPolygons;
    while (current != NULL) {
        totalMoment += cpMomentForPoly(pPhxSprite->m_mass / pPhxSprite->m_decomposedPolygons->vertexCount, current->vertexCount, current->vertices, cpvzero, 0.0);
        current = current->next;
    }

    cpSpace* space = ObjsBuilder_getPhxSpace();
    pPhxSprite->m_body = cpSpaceAddBody(space, cpBodyNew(pPhxSprite->m_mass, totalMoment));
   
    cpBodySetPosition(pPhxSprite->m_body, cpv(pPhxSprite->m_rect.x + pPhxSprite->m_center.x, 
        SCREEN_HEIGHT - (pPhxSprite->m_rect.y + pPhxSprite->m_center.y)));

    current = pPhxSprite->m_decomposedPolygons;
    while (current != NULL) {
        current->shape = cpSpaceAddShape(space, cpPolyShapeNew(pPhxSprite->m_body, current->vertexCount, current->vertices, cpTransformIdentity, 0.0));
        if( pPhxSprite->m_group != 0 ){
            cpShapeFilter filter = cpShapeFilterNew(CP_NO_GROUP, pPhxSprite->m_group, ~pPhxSprite->m_group);
            cpShapeSetFilter(current->shape, filter);
        }
        cpShapeSetFriction(current->shape, 0.7);
        current = current->next;
    }
    return TRUE;
} /* PhxSprite_load */

/** @public @memberof PhxSprite */
static void PhxSprite_free(
    Sprite* pSprite
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
    if (pPhxSprite->m_image) {
        SDL_DestroyTexture(pPhxSprite->m_image);
    }
    freePolygons(pPhxSprite->m_decomposedPolygons);        
    cpBodyFree(pPhxSprite->m_body);    

    PhxJoint* pCurJoint = pPhxSprite->m_joints;
    while( pCurJoint != null ){
        PhxJoint_free( pCurJoint );
        pCurJoint = PhxJoint_getNext( pCurJoint );
    }    
} /* PhxSprite_free */

/** @public @memberof PhxSprite */
cpBody* PhxSprite_getBody(
    PhxSprite* pPhxSprite
){
    return pPhxSprite->m_body;
} /* PhxSprite_getBody */

/** @public @memberof PhxSprite */
static const SDL_Point* PhxSprite_getCenter(
    Sprite* pSprite
){
    PhxSprite* pPhxSprite = ( PhxSprite* )pSprite;
    cpVect wldCenter = cpBodyLocalToWorld( pPhxSprite->m_body, cpvzero );
    pPhxSprite->m_sdlCenter = ( SDL_Point ){ ( int )wldCenter.x, ObjsBuilder_getScreenHeight() - ( int )wldCenter.y };
    return &pPhxSprite->m_sdlCenter;
} /* PhxSprite_getCenter */

Sprite* PhxSprite_Copy( PhxSprite* pPhxSprite, const PhxSprite* pSource ){
    Sprite_Copy( ( Sprite* )pPhxSprite, ( Sprite* )pSource );
    pPhxSprite->m_verts = pSource->m_verts;
    pPhxSprite->m_vertsCnt = pSource->m_vertsCnt;
    pPhxSprite->m_center = pSource->m_center;
    pPhxSprite->m_mass = pSource->m_mass;
    pPhxSprite->m_group = pSource->m_group;
    pPhxSprite->m_joints = pSource->m_joints;
    pPhxSprite->m_body = pSource->m_body;
    pPhxSprite->m_shape = pSource->m_shape;
    pPhxSprite->m_decomposedPolygons = pSource->m_decomposedPolygons;
    pPhxSprite->m_sdlCenter = pSource->m_sdlCenter;
    return ( Sprite* )pPhxSprite;
}
const SpriteVtbl gPhxSpriteVtbl = {
    .pdraw0                      = PhxSprite_draw0,
    .pupdate                     = PhxSprite_update,
    .pupdateMouseState           = PhxSprite_updateMouseState,
    .pdraw1                      = PhxSprite_draw1,
    .pload                       = PhxSprite_load,
    .pfree                       = PhxSprite_free,
    .pgetCenter                  = PhxSprite_getCenter,
};
