/* File generated by Đức's ClasHStamP */
#define __PhxSprite_INTERNAL__
#include "CommonInclude.h"
#include "PhxSprite.h"
#include "ObjsBuilder.h"                                        
/** @public @memberof PhxSprite */
static void PhxSprite_draw0(
    PhxSprite* pPhxSprite,
    SDL_Renderer* renderer
){
} /* PhxSprite_draw0 */

/** @public @memberof PhxSprite */
static void PhxSprite_update(
    PhxSprite* pPhxSprite
){
} /* PhxSprite_update */

/** @public @memberof PhxSprite */
static void PhxSprite_updateMouseState(
    PhxSprite* pPhxSprite,
    int x,
    int y,
    int mouseEvent
){
} /* PhxSprite_updateMouseState */

/** @public @memberof PhxSprite */
static void PhxSprite_draw1(
    PhxSprite* pPhxSprite,
    SDL_Renderer* renderer
){
    // Get the size of the renderer
    int SCREEN_WIDTH, SCREEN_HEIGHT;
    if (SDL_GetRendererOutputSize(renderer, &SCREEN_WIDTH, &SCREEN_HEIGHT) != 0) {
        printf("Error getting renderer size: %s\n", SDL_GetError());
    }

    // Render the texture
    cpVect pos = cpBodyGetPosition(pPhxSprite->m_body);
    cpFloat angle = cpBodyGetAngle(pPhxSprite->m_body);
    double degrees = -angle * (180.0 / M_PI); // Convert radians to degrees
    //cpBB bb = cpShapeCacheBB( pPhxSprite->m_shape );
    //SDL_Rect rect = ( SDL_Rect ){ .x = bb.l, .y = SCREEN_HEIGHT - bb.t, .w = bb.r - bb.l, .h = bb.t - bb.b };
    SDL_Rect rect = pPhxSprite->m_rect;
    rect.x = pos.x;
    rect.y = ( SCREEN_HEIGHT - (pos.y + pPhxSprite->m_rect.h) );
    SDL_RenderCopyEx(renderer, pPhxSprite->m_image, NULL, &rect, degrees, NULL, SDL_FLIP_NONE);
} /* PhxSprite_draw1 */

/** @public @memberof PhxSprite */
static bool PhxSprite_load(
    PhxSprite* pPhxSprite,
    SDL_Renderer* renderer
){
    char sRelPath[ 256 ];
    sprintf( sRelPath, "%s/../%s", getInputDir(), pPhxSprite->m_imgPath );
    // Load PNG image
    SDL_Texture* pPngImg = IMG_LoadTexture(renderer, sRelPath);
    if (!pPngImg) {
        printf("Failed to load image: %s\n", IMG_GetError());
        return false;
    }

    // Get the size of the renderer
    int SCREEN_WIDTH, SCREEN_HEIGHT;
    if (SDL_GetRendererOutputSize(renderer, &SCREEN_WIDTH, &SCREEN_HEIGHT) != 0) {
        printf("Error getting renderer size: %s\n", SDL_GetError());
    }

    pPhxSprite->m_rect = (SDL_Rect){
        pPhxSprite->m_iniRect.x * SCREEN_WIDTH, 
        pPhxSprite->m_iniRect.y * SCREEN_HEIGHT, 
        pPhxSprite->m_iniRect.w * SCREEN_WIDTH, 
        pPhxSprite->m_iniRect.h * SCREEN_HEIGHT
    };

    // Query the original texture to get its width, height, and format
    Uint32 format;
    int width, height;
    SDL_QueryTexture(pPngImg, &format, NULL, &width, &height);

    pPhxSprite->m_image = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, width, height);

    // Set the blend mode for the new texture to enable alpha blending
    SDL_SetTextureBlendMode(pPhxSprite->m_image, SDL_BLENDMODE_BLEND);
    // Set the render target to the buffer texture
    SDL_SetRenderTarget(renderer, pPhxSprite->m_image);

    //SDL_RenderCopy( renderer, pPngImg, NULL, NULL );

    for( int i = 0; i < pPhxSprite->m_vertsCnt; i++ ){
        pPhxSprite->m_verts[ i ].x *= width;
        pPhxSprite->m_verts[ i ].y = height - pPhxSprite->m_verts[ i ].y * height ;
        circleRGBA( renderer, pPhxSprite->m_verts[ i ].x , height - pPhxSprite->m_verts[ i ].y, 1, 0, 0, 0, 0xFF );
    }

    // Recover render target
    SDL_SetRenderTarget(renderer, NULL);

    // Free PNG image
    SDL_DestroyTexture(pPngImg);
    
    // Set physic information
    cpFloat moment = cpMomentForPoly(pPhxSprite->m_mass, pPhxSprite->m_vertsCnt, pPhxSprite->m_verts, cpvzero, 0.0);
    cpSpace* space = ObjsBuilder_getPhxSpace();
    pPhxSprite->m_body = cpSpaceAddBody(space, cpBodyNew(pPhxSprite->m_mass, moment));
    cpBodySetPosition(pPhxSprite->m_body, cpv(pPhxSprite->m_rect.x, SCREEN_HEIGHT - (pPhxSprite->m_rect.y + pPhxSprite->m_rect.h)));

    pPhxSprite->m_shape = cpSpaceAddShape(space, cpPolyShapeNew(pPhxSprite->m_body, pPhxSprite->m_vertsCnt, pPhxSprite->m_verts, cpTransformIdentity, 0.0) );
    cpShapeSetFriction(pPhxSprite->m_shape, 0.7);
    return TRUE;
} /* PhxSprite_load */

/** @public @memberof PhxSprite */
static void PhxSprite_free(
    PhxSprite* pPhxSprite
){
    if (pPhxSprite->m_image) {
        SDL_DestroyTexture(pPhxSprite->m_image);
    }
    cpShapeFree(pPhxSprite->m_shape);
    cpBodyFree(pPhxSprite->m_body);    
} /* PhxSprite_free */

Sprite* PhxSprite_Copy( PhxSprite* pPhxSprite, const PhxSprite* pSource ){
    Sprite_Copy( ( Sprite* )pPhxSprite, ( Sprite* )pSource );
    pPhxSprite->m_verts = pSource->m_verts;
    pPhxSprite->m_vertsCnt = pSource->m_vertsCnt;
    pPhxSprite->m_center = pSource->m_center;
    pPhxSprite->m_mass = pSource->m_mass;
    pPhxSprite->m_body = pSource->m_body;
    pPhxSprite->m_shape = pSource->m_shape;
    return ( Sprite* )pPhxSprite;
}
const SpriteVtbl gPhxSpriteVtbl = {
    .pdraw0                      = PhxSprite_draw0,
    .pupdate                     = PhxSprite_update,
    .pupdateMouseState           = PhxSprite_updateMouseState,
    .pdraw1                      = PhxSprite_draw1,
    .pload                       = PhxSprite_load,
    .pfree                       = PhxSprite_free,
};
