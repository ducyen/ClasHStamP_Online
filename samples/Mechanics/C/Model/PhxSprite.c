/* File generated by Đức's ClasHStamP */
#define __PhxSprite_INTERNAL__
#include "CommonInclude.h"
#include "PhxSprite.h"
/** @public @memberof PhxSprite */
static void PhxSprite_draw0(
    PhxSprite* pPhxSprite,
    SDL_Renderer* renderer
){
} /* PhxSprite_draw0 */

/** @public @memberof PhxSprite */
static void PhxSprite_update(
    PhxSprite* pPhxSprite
){
} /* PhxSprite_update */

/** @public @memberof PhxSprite */
static void PhxSprite_updateMouseState(
    PhxSprite* pPhxSprite,
    int x,
    int y,
    int mouseEvent
){
} /* PhxSprite_updateMouseState */

/** @public @memberof PhxSprite */
static void PhxSprite_draw1(
    PhxSprite* pPhxSprite,
    SDL_Renderer* renderer
){
    // Render the texture
    SDL_RenderCopyEx(renderer, pPhxSprite->m_image, NULL, &pPhxSprite->m_rect, 0, NULL, SDL_FLIP_NONE);
} /* PhxSprite_draw1 */

/** @public @memberof PhxSprite */
static bool PhxSprite_load(
    PhxSprite* pPhxSprite,
    SDL_Renderer* renderer
){
    char sRelPath[ 256 ];
    sprintf( sRelPath, "%s/../%s", getInputDir(), pPhxSprite->m_imgPath );
    // Load PNG image
    SDL_Texture* pPngImg = IMG_LoadTexture(renderer, sRelPath);
    if (!pPngImg) {
        printf("Failed to load image: %s\n", IMG_GetError());
        return false;
    }

    int width, height;
    // Get the size of the renderer
    if (SDL_GetRendererOutputSize(renderer, &width, &height) != 0) {
        printf("Error getting renderer size: %s\n", SDL_GetError());
    }

    pPhxSprite->m_rect = (SDL_Rect){
        pPhxSprite->m_iniRect.x * width, 
        pPhxSprite->m_iniRect.y * height, 
        pPhxSprite->m_iniRect.w * width, 
        pPhxSprite->m_iniRect.h * height
    };

    // Query the original texture to get its width, height, and format
    Uint32 format;
    SDL_QueryTexture(pPngImg, &format, NULL, &width, &height);

    pPhxSprite->m_image = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, width, height);

    // Set the blend mode for the new texture to enable alpha blending
    SDL_SetTextureBlendMode(pPhxSprite->m_image, SDL_BLENDMODE_BLEND);
    // Set the render target to the buffer texture
    SDL_SetRenderTarget(renderer, pPhxSprite->m_image);

    SDL_RenderCopy( renderer, pPngImg, NULL, NULL );

    cpFloat vertX = 0, vertY = 0;
    for( int i = 0; i < pPhxSprite->m_vertsCnt; i++ ){
        pPhxSprite->m_verts[ i ].x *= width;
        pPhxSprite->m_verts[ i ].y *= height;
        if( i > 0 ){
            lineRGBA( renderer, vertX, vertY, pPhxSprite->m_verts[ i ].x , pPhxSprite->m_verts[ i ].y, 0, 0, 0, 0xFF );
        }
        vertX = pPhxSprite->m_verts[ i ].x;
        vertY = pPhxSprite->m_verts[ i ].y;
    }

    // Recover render target
    SDL_SetRenderTarget(renderer, NULL);

    // Free PNG image
    SDL_DestroyTexture(pPngImg);

    return TRUE;
} /* PhxSprite_load */

/** @public @memberof PhxSprite */
static void PhxSprite_free(
    PhxSprite* pPhxSprite
){
    if (pPhxSprite->m_image) {
        SDL_DestroyTexture(pPhxSprite->m_image);
    }
} /* PhxSprite_free */

Sprite* PhxSprite_Copy( PhxSprite* pPhxSprite, const PhxSprite* pSource ){
    Sprite_Copy( ( Sprite* )pPhxSprite, ( Sprite* )pSource );
    pPhxSprite->m_verts = pSource->m_verts;
    pPhxSprite->m_vertsCnt = pSource->m_vertsCnt;
    pPhxSprite->m_mass = pSource->m_mass;
    return ( Sprite* )pPhxSprite;
}
const SpriteVtbl gPhxSpriteVtbl = {
    .pdraw0                      = PhxSprite_draw0,
    .pupdate                     = PhxSprite_update,
    .pupdateMouseState           = PhxSprite_updateMouseState,
    .pdraw1                      = PhxSprite_draw1,
    .pload                       = PhxSprite_load,
    .pfree                       = PhxSprite_free,
};
