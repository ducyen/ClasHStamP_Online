/* File generated by Đức's ClasHStamP */
#define __ObjsBuilder_INTERNAL__
#include "CommonInclude.h"
#include "ObjsBuilder.h"
#include "Primitive.h"                                          
#include "TranslationConstraint.h"                              
#include "AttachmentConstraint.h"                               
#include "RotationConstraint.h"                                 
#include "TrackToConstraint.h"                                  
#include "FlexButton.h"                                         
#include "MouseListener.h"                                      
#include "PhxSprite.h"                                          
/** @private @static @memberof ObjsBuilder */
static int hardwareAccelerationAvailable = SDL_RENDERER_SOFTWARE;
Sprite* g_objects[] = {
    &FlexButton_Ctor(                                           /* pushButton */
        P( { 0.056028795455243065, 0.8271639811357832, 0.022938418666529032, 0.027533292960755917 } )/* m_iniRect */,
        P( "pushButton" )                                       /* m_name */,
        P( "FlexButton.png" )                                   /* m_imgPath */,
        P( 1 )                                                  /* m_valueMax */,
        P( FlexBtnStm_PushStyle )                               /* m_style */,
        P( &MouseListener_Ctor( SDL_MOUSEBUTTONDOWN | SDL_BUTTON_LEFT, FlexButton_EventProc, &pushButton, FlexButton_MOUSE_DOWN, &MouseListener_Ctor( SDL_MOUSEBUTTONUP | SDL_BUTTON_LEFT, FlexButton_EventProc, &pushButton, FlexButton_MOUSE_UP, &MouseListener_Ctor( SDL_MOUSEMOTION | SDL_BUTTON_LEFT, FlexButton_EventProc, &pushButton, FlexButton_MOUSE_MOVE, null ) ) ) )/* m_mouseListeners */,
        P( null )                                               /* m_buttonListeners */
    ),
    &PhxSprite_Ctor(                                            /* craneArmRight */
        P( { 0.33629938749411054, 0.22794081090118218, 0.08760853469744906, 0.1594769725394011 } )/* m_iniRect */,
        P( "craneArmRight" )                                    /* m_name */,
        P( "crane_game_arm_right.png" )                         /* m_imgPath */,
        P( (cpVect[]){ {0.6455669420959047, 0.5775417564080823}, {0.038216873287344216, 0.11287565195847686}, {0.09872646013881789, 0.0025259834192732553}, {0.32484140430769826, 0.009017096793461838}, {1.0000003925210355, 0.560765068900481}, {0.3248410406683542, 0.9999997503633445}, {5.600627722643381E-7, 0.9523978405204073}, {0.21019173735529426, 0.8896502053538072} } )/* m_verts */,
        P( 8 )                                                  /* m_vertsCnt */,
        P( 1 )                                                  /* m_mass */
    ),
    &PhxSprite_Ctor(                                            /* craneArmLeft */
        P( { 0.2363306660754091, 0.22832197793520542, 0.08760853469744906, 0.1594769725394011 } )/* m_iniRect */,
        P( "craneArmLeft" )                                     /* m_name */,
        P( "crane_game_arm_left.png" )                          /* m_imgPath */,
        P( (cpVect[]){ {0.3544330031661922, 0.5775418768702598}, {0.9617834356140967, 0.11287577242065434}, {0.9012738487626231, 0.0025261038814507475}, {0.6751589045937427, 0.00901721725563933}, {-8.361959447478349E-8, 0.5607653128923248}, {0.6751592682330868, 0.9999999943551883}, {0.9999997488386687, 0.952398084512251}, {0.7898085715461467, 0.889650449345651} } )/* m_verts */,
        P( 8 )                                                  /* m_vertsCnt */,
        P( 1 )                                                  /* m_mass */
    ),
    &PhxSprite_Ctor(                                            /* craneArmMain */
        P( { 0.2672925022469108, 0.10173991540236522, 0.12460119808844317, 0.20302262533425228 } )/* m_iniRect */,
        P( "craneArmMain" )                                     /* m_name */,
        P( "crane_game_arm_main.png" )                          /* m_imgPath */,
        P( (cpVect[]){ {0.49737153987685784, 0.005497538757085408}, {0.2629437221290666, 0.053251949686569655}, {0.08712305185380674, 0.2049425446681477}, {0.0037208697361021856, 0.41843299385986243}, {0.005975010591259407, 0.6263052015894935}, {0.12769707248508042, 0.831368288588083}, {0.2990094610500258, 0.9633953592014816}, {0.5018795642063941, 0.9971043268503134}, {0.7498317123235724, 0.9437316744587456}, {0.8986032070985019, 0.8117047642199035}, {0.9955297195855934, 0.6178779997709247}, {0.9955297195855934, 0.41843299385986243}, {0.9211441008885178, 0.2077516653991895}, {0.7520855957979515, 0.06448843261073674} } )/* m_verts */,
        P( 14 )                                                 /* m_vertsCnt */,
        P( 1 )                                                  /* m_mass */
    ),
    &PhxSprite_Ctor(                                            /* prize0 */
        P( { 0.27433968539290254, 0.462930287376547, 0.0945993813962704, 0.16810294824414587 } )/* m_iniRect */,
        P( "prize0" )                                           /* m_name */,
        P( "crane_game_prize.png" )                             /* m_imgPath */,
        P( (cpVect[]){ {0.2957885892722899, 0.0641448944523701}, {0.46950552762620423, 0.03947389053036527}, {0.6385278844861888, 0.05592128907860579}, {0.7089535761265405, 2.4669501516197623E-7}, {0.8545003450432589, 0.024671438417731898}, {0.875627838097475, 0.12171088327156787}, {0.8052021464571233, 0.1661188030116037}, {0.8991034260407412, 0.3421057233368518}, {0.8028545876627967, 0.4769740533911426}, {0.995351996371324, 0.6578954374217884}, {0.995351996371324, 0.7220402729798552}, {0.9178836283479924, 0.738487295926672}, {0.760599065459641, 0.6694085600653432}, {0.7699893006369475, 0.8832245533917581}, {0.7183438113038471, 0.9802639982455941}, {0.6361803256918622, 0.9819083812790654}, {0.5070662002880685, 0.8371714994154031}, {0.4225554239291188, 0.9934215039226203}, {0.3239590267568476, 1.0000005384622013}, {0.2371004235562096, 0.8585531738683294}, {0.21832022124895836, 0.6924346175517408}, {0.08920609584516462, 0.7582242117447029}, {0.016432577363124555, 0.751645177205122}, {-6.614980005209915E-8, 0.6858555830121599}, {0.19484490135305388, 0.4901317468688808}, {0.07277345233224002, 0.3651317808232495}, {0.1385042944313002, 0.1776317378544466}, {0.05399325002498878, 0.13322381811441075}, {0.09624877222814449, 0.03618437326057478}, {0.2300580152205915, 0.018092216077439018} } )/* m_verts */,
        P( 30 )                                                 /* m_vertsCnt */,
        P( 1 )                                                  /* m_mass */
    )
};
Sprite* getobj( int id ){
    return g_objects[ id ];
}
int ObjsBuilder_startSim(
    void  
){
    cpVect gravity = cpv(0, 100);
    cpSpace *space = ObjsBuilder_getPhxSpace();
    cpSpaceSetGravity(space, gravity);

    SDL_Window *window = NULL;
    SDL_Renderer *renderer = NULL;
    SDL_Surface *imageSurface = NULL;
    SDL_Texture *imageTexture = NULL;

    int nResult = S_OK;

    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        nResult = S_FALSE;
    }
    // Initialize SDL_ttf
    if (nResult == S_OK && TTF_Init() == -1) {
        printf("TTF could not initialize! TTF_Error: %s\n", TTF_GetError());
        nResult = S_FALSE;
    }
    int SCREEN_WIDTH = 640;
    int SCREEN_HEIGHT = 480;

    if (nResult == S_OK) {
        // Load image
        char sRelPath[1024];
        sprintf(sRelPath, "%s/%s", getInputDir(), "ObjsBuilder/Main.png");
        imageSurface = IMG_Load(sRelPath);
        if (imageSurface == NULL) {
            printf("Unable to load image! SDL_image Error: %s\n", IMG_GetError());
            nResult = S_FALSE;
        } else {
            SCREEN_WIDTH = imageSurface->w;
            SCREEN_HEIGHT = imageSurface->h;
        }
    }

    if (nResult == S_OK) {
        SDL_RendererInfo rendererInfo;
        int numRenderDrivers = SDL_GetNumRenderDrivers();

        for (int i = 0; i < numRenderDrivers; ++i) {
            if (SDL_GetRenderDriverInfo(i, &rendererInfo) == 0) {
                if (rendererInfo.flags & SDL_RENDERER_ACCELERATED) {
                    printf("Hardware acceleration is available for renderer: %s\n", rendererInfo.name);
                    //hardwareAccelerationAvailable = SDL_RENDERER_ACCELERATED;
                    break;
                }
            }
        }

        window = SDL_CreateWindow("Model Driven Development", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
        if (window == NULL) {
            printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
            nResult = S_FALSE;
        } else {
            renderer = SDL_CreateRenderer(window, -1, hardwareAccelerationAvailable);
            if (renderer == NULL) {
                printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
                nResult = S_FALSE;
            }
        }
    }

    if (nResult == S_OK && imageSurface != NULL) {
        // Create a texture from the loaded surface
        imageTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, SCREEN_WIDTH, SCREEN_HEIGHT);
        if (imageTexture == NULL) {
            printf("Unable to create texture! SDL_Error: %s\n", SDL_GetError());
            nResult = S_FALSE;
        }
    }

    // Initialize SDL_image
    if (nResult == S_OK && !(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG)) {
        printf("SDL_image could not initialize! SDL_image Error: %s\n", IMG_GetError());
        nResult = S_FALSE;
    }

    for( int i = 0; i < sizeof( g_objects ) / sizeof( g_objects[ 0 ] ) && nResult == S_OK; i++ ){
        if( Sprite_load( g_objects[ i ], renderer ) == false ){
            nResult = S_FALSE;
        }
    }

    if( nResult == S_OK ){
            // Set the new texture as the render target
        SDL_SetRenderTarget(renderer, imageTexture);

        // Clear screen
        SDL_SetRenderDrawColor(renderer, 0xFF, 0xFF, 0xFF, 0xFF); // White
        SDL_RenderClear(renderer);

        for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
            Sprite_draw0(g_objects[i], renderer);
        }

        // Reset the render target to the default
        SDL_SetRenderTarget(renderer, NULL);       
    }
    
    //carBody->m_stmShow = true;

    if (nResult == S_OK) {
        bool quit = false;
        SDL_Event e;

        while (!quit) {
            bool hasUpdated = true;
            while( hasUpdated ){
                for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
                    if( Sprite_isUpdated(g_objects[i]) ){
                        Sprite_update(g_objects[i]);
                    }
                }
                hasUpdated = false;
                for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
                    if( Sprite_isUpdated(g_objects[i]) ){
                        hasUpdated = true;
                    }
                }
            }

            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    quit = true;
                }else if (e.type == SDL_WINDOWEVENT) {
                    if (e.window.event == SDL_WINDOWEVENT_CLOSE) {
                        for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
                            Sprite* pSprite = g_objects[i];
                            if( SDL_GetWindowID( pSprite->m_stmWindow ) == e.window.windowID ){
                                if( pSprite->m_stmWindow != null ){
                                    int textureCount = (int)(intptr_t)SDL_GetWindowData(g_objects[i]->m_stmWindow, "textureCount");
                                    for (int j = 1; j <= textureCount; j++) {
                                        char key[20];
                                        snprintf(key, 20, "texture%d", j);
                                        SDL_Texture* texture = (SDL_Texture*)SDL_GetWindowData(g_objects[i]->m_stmWindow, key);
                                        SDL_DestroyTexture(texture);
                                        SDL_SetWindowData(g_objects[i]->m_stmWindow, key, NULL);
                                    }
                                    SDL_SetWindowData(g_objects[i]->m_stmWindow, "textureCount", (void*)(intptr_t)0);

                                    SDL_DestroyWindow( pSprite->m_stmWindow );
                                    SDL_Renderer* stmRenderer = SDL_GetRenderer( pSprite->m_stmWindow );
                                    SDL_DestroyRenderer( stmRenderer );
                                    SDL_DestroyTexture( pSprite->m_stmTexture );
                                    pSprite->m_stmWindow = null;
                                    pSprite->m_stmShow = false;
                                }
                            }
                        }
                    }
                } else if (e.type == SDL_MOUSEWHEEL 
                    || e.type == SDL_MOUSEBUTTONDOWN 
                    || e.type == SDL_MOUSEBUTTONUP 
                    || e.type == SDL_MOUSEMOTION 
                ){
                    for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
                        int mouseX = e.button.x;
                        int mouseY = e.button.y;
                        Sprite_updateMouseState(g_objects[i], mouseX, mouseY, e.type | e.button.button);
                    }
                    break;
                } else if (e.type == SDL_KEYDOWN) {
                    if (e.key.keysym.sym == SDLK_x) {
                    }else if (e.key.keysym.sym == SDLK_r) {
                    }else if (e.key.keysym.sym == SDLK_l) {
                    }
                }
            }
            // Update physics
            cpSpaceStep(space, 1.0 / 60.0);

            // Render the image texture
            if (imageTexture != NULL) {
                SDL_RenderCopy(renderer, imageTexture, NULL, NULL);
            }

            for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
                Sprite_draw1(g_objects[i], renderer);
            }

            // Update the screen
            SDL_RenderPresent(renderer);
            for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
                if( g_objects[i]->m_stmShow && g_objects[i]->m_stmUpdated  ){
                    SDL_Renderer* stmRenderer = SDL_GetRenderer( g_objects[i]->m_stmWindow );
                    SDL_SetRenderTarget(stmRenderer, NULL);
                    SDL_RenderCopy(stmRenderer, g_objects[i]->m_stmTexture, NULL, NULL);
                    SDL_RenderPresent(stmRenderer);
                    g_objects[i]->m_stmUpdated = false;
                }
            }
            // Delay to control the animation speed
            SDL_Delay(16);
        }
    }

    for (int i = 0; i < sizeof(g_objects) / sizeof(g_objects[0]); i++) {
        if( g_objects[i]->m_stmWindow != null ){
            int textureCount = (int)(intptr_t)SDL_GetWindowData(g_objects[i]->m_stmWindow, "textureCount");
            for (int i = 1; i <= textureCount; i++) {
                char key[20];
                snprintf(key, 20, "texture%d", i);
                SDL_Texture* texture = (SDL_Texture*)SDL_GetWindowData(g_objects[i]->m_stmWindow, key);
                SDL_DestroyTexture(texture);
                SDL_SetWindowData(g_objects[i]->m_stmWindow, key, NULL);
            }
            SDL_SetWindowData(g_objects[i]->m_stmWindow, "textureCount", (void*)(intptr_t)0);
        }
        Sprite_free(g_objects[i]);
    }

    // Free resources and close SDL
    SDL_DestroyTexture(imageTexture);
    SDL_FreeSurface(imageSurface);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_Quit();    
    IMG_Quit();
    SDL_Quit();

    // Clean up
    cpSpaceFree(space);

    return 0;
} /* ObjsBuilder_startSim */

void ObjsBuilder_showEntry(
    void* pObj,
    void* pStm_,
    char* pMsg
){
    ObjsBuilder_showDiagram( pObj, pStm_, pMsg, 0x00, 0xFF, 0x00 );
} /* ObjsBuilder_showEntry */

void ObjsBuilder_showDoing(
    void* pObj,
    void* pStm_,
    char* pMsg
){
    ObjsBuilder_showDiagram( pObj, pStm_, pMsg, 0x00, 0x00, 0xFF );
} /* ObjsBuilder_showDoing */

void ObjsBuilder_showExit(
    void* pObj,
    void* pStm_,
    char* pMsg
){
    ObjsBuilder_showDiagram( pObj, pStm_, pMsg, 0xFF, 0x00, 0x00 );
} /* ObjsBuilder_showExit */

void ObjsBuilder_showDiagram(
    void* pObj,
    void* pStm_,
    char* pMsg,
    char r,
    char g,
    char b
){
    Sprite* pSprite = ( Sprite* )pObj;
    if( pSprite->m_stmShow == false ){
        return;
    }
    HdStateMachine* pStm = ( HdStateMachine* )pStm_;
    char s[ 256 ];
    int l, t, w, h, dgrX, dgrY, dgrW, dgrH;
    sscanf( pMsg, "%s%d%d%d%d%d%d%d%d", s, &l, &t, &w, &h, &dgrX, &dgrY, &dgrW, &dgrH );
    if( pSprite->m_stmWindow == null ){
        int SCREEN_WIDTH = 0;
        int SCREEN_HEIGHT = 0;
        char windowName[255];
        sprintf(windowName, "%s - %s", s, pSprite->m_name);
        pSprite->m_stmWindow = SDL_CreateWindow(windowName, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
        SDL_CreateRenderer(pSprite->m_stmWindow, -1, hardwareAccelerationAvailable);
    }
    SDL_Texture* stmImage = pStm->m_stmImage;
    SDL_Rect* stmRect = &pStm->m_stmRect;
    if( stmImage == null ){
        stmImage = SDL_GetWindowData(pSprite->m_stmWindow, s);
        if( stmImage != null){
            char rectKey[255];
            snprintf(rectKey, 255, "%s-rect", s);
            stmRect = SDL_GetWindowData(pSprite->m_stmWindow, rectKey);
        }
    }
    if( stmImage == null ){
        char sRelPath[256];
        sprintf(sRelPath, "%s/%s.png", getInputDir(), s);
        SDL_Surface *imageSurface = IMG_Load(sRelPath);
        pStm->m_stmRect.w = imageSurface->w;
        pStm->m_stmRect.h = imageSurface->h;
        SDL_Renderer* stmRenderer = SDL_GetRenderer( pSprite->m_stmWindow );
        pStm->m_stmImage = SDL_CreateTextureFromSurface(stmRenderer, imageSurface);
        int width, height;
        SDL_GetWindowSize( pSprite->m_stmWindow, &width, &height );
        pStm->m_stmRect.x = 0;
        pStm->m_stmRect.y = height;
        if( width < pStm->m_stmRect.w ){
            width = pStm->m_stmRect.w;
        }
        height = height + pStm->m_stmRect.h;
        SDL_SetWindowSize( pSprite->m_stmWindow, width, height );
        SDL_FreeSurface(imageSurface);

        Uint32 format;
        int dmyW, dmyH;
        SDL_QueryTexture(pStm->m_stmImage, &format, NULL, &dmyW, &dmyH);

        // Create a new texture with the same format and dimensions
        if( pSprite->m_stmTexture != null ){
            SDL_DestroyTexture(pSprite->m_stmTexture);
        }
        pSprite->m_stmTexture = SDL_CreateTexture(stmRenderer, format, SDL_TEXTUREACCESS_TARGET, width, height);

        // Get current texture count from window data
        int textureCount = (int)(intptr_t)SDL_GetWindowData(pSprite->m_stmWindow, "textureCount");
        textureCount++; // Increment texture count        
        // Store texture using a key based on new count
        char key[20];
        snprintf(key, 20, "texture%d", textureCount);
        SDL_SetWindowData(pSprite->m_stmWindow, key, pStm->m_stmImage);
        SDL_SetWindowData(pSprite->m_stmWindow, "textureCount", (void*)(intptr_t)textureCount);
        
        SDL_SetWindowData(pSprite->m_stmWindow, s, pStm->m_stmImage);
        char rectKey[255];
        snprintf(rectKey, 255, "%s-rect", s);
        SDL_SetWindowData(pSprite->m_stmWindow, rectKey, &pStm->m_stmRect);

        stmImage = pStm->m_stmImage;
        stmRect = &pStm->m_stmRect;
        pSprite->m_stmUpdated = false;
    }
    
    SDL_Renderer* stmRenderer = SDL_GetRenderer( pSprite->m_stmWindow );        
    if( !pSprite->m_stmUpdated ){
        SDL_SetRenderTarget(stmRenderer, pSprite->m_stmTexture);
        SDL_RenderCopy(stmRenderer, stmImage, NULL, stmRect);
    }

    int nTop = ( float )( t - dgrY ) + stmRect->y;
    int nLeft = ( float )( l - dgrX );
    int nHeight = ( float )h;
    int nWidth = ( float )w;
    UINT nDotSize = 3;

    rectangleRGBA( stmRenderer, nLeft, nTop, nLeft + nWidth, nTop + nHeight, r, g, b, 0xFF );

    pSprite->m_stmUpdated = true;     
} /* ObjsBuilder_showDiagram */

cpSpace* ObjsBuilder_getPhxSpace(
    void  
){
    static cpSpace* space = null;
    if( space == null ){
        space = cpSpaceNew();
    }
    return space;
} /* ObjsBuilder_getPhxSpace */

ObjsBuilder* ObjsBuilder_Copy( ObjsBuilder* pObjsBuilder, const ObjsBuilder* pSource ){
    return ( ObjsBuilder* )pObjsBuilder;
}
